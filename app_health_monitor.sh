#!/bin/bash
#-------------------------------------------------------------------------------
# Script to check health of appname application directly on the localhost interface
#
# - Script runs constantly and checks health periodically
# - Sets mutex lock to prevent multiple copies of this script from running
#    concurrently.  This allows use of cron as a watchdog to ensure that this
#    script is always running.
# - Automatically deletes old log files generated by this script
#
# Author:vishnugantam@outlook.com
#
#-------------------------------------------------------------------------------

# Define parameters for logs generated by this script
log_dir="/app/logs/tomcat"
log_name_base="appname_health_monitor.log"
log_name=$(date "+${log_name_base}.%Y-%m-%d")
log_retention_days=7

# String indicating health check success
health_ok_string="Health Check Ok"

# Frequency in seconds for calling app_info
freq_app_info=300

# Verify that a reasonable path is set
export PATH=/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin

# Restrict script to root user
whoami=$(/usr/bin/whoami)
if [[ $whoami != "root" ]]; then
  echo "Must be root to execute this script"
  exit 1
fi

start_msg=$(date "+%Y-%m-%d %H:%M:%S [$$] Starting monitor")

# Set mutex lock to prevent multiple copies of this script from running
#  This gets released explicitly before restarting stunnel (if necessary)
#  or released implicitly otherwise
exec 202>/var/tmp/appname_health_monitor.lock
flock -xn 202
if [[ "$?" != "0" ]]; then
  echo "$start_msg - Can't get mutex lock - Terminating" | tee -a $log_dir/$log_name
  exit 0
fi

echo "$start_msg" | tee -a $log_dir/$log_name

# Initialize timer since last app_info call
echo -n "0" >/tmp/.appname_health_monitor.last_app_info

# Infinite loop
while :; do

  # Set current log file name
  log_name=$(date "+${log_name_base}.%Y-%m-%d")

  # Remove old log files
  find $log_dir -type f -name "$log_name_base.*" -mtime +${log_retention_days} -exec rm -f {} \;

   # Get IP address of this host
  ip_addr=$(ifconfig -a | grep "inet addr" | grep -v 127.0.0.1 | sed 's/^.*inet addr:\([0-9\.][0-9\.]*\).*$/\1/' | tr "\n", " ")

  # Check health of application on non-encrypted port on local interface
  app_health_msg=$(
    curl  -ksS --connect-timeout 2 --max-time 2 https://localhost:8443/health/full 2>/dev/null
  )
  app_health_status=$(echo "$app_health_msg" | grep -c "$health_ok_string")

  (
    base_msg="host_ip=$ip_addr app_health_status=$app_health_status"

    # Check to see if application is healthy
    if (( app_health_status == 0)); then
      echo "$base_msg Application health check failed"
      echo "   app_health_message=$app_health_msg"

    else
      echo "$base_msg Application Health Check Ok"

      # Check to see if it is time to do an app_info call
      now=$(date "+%s")
      last_app_info=$(cat /tmp/.appname_health_monitor.last_app_info)
      if ((now - last_app_info > freq_app_info)); then
        app_info_msg=$(curl  -ksS --connect-timeout 2 --max-time 2 https://localhost:8443/app-info 2>/dev/null)
        echo "app_info=$app_info_msg"
        echo -n "$now" >/tmp/.appname_health_monitor.last_app_info
      fi
    fi
  ) |
  while read line; do
    # Get current time
    now=$(date "+%Y-%m-%d %H:%M:%S")

    # Write to log file with timestamp
    echo "$now [$$] $line" >>$log_dir/$log_name 2>&1
  done

  chmod 644 $log_dir/$log_name
  chown app:appadmin $log_dir/$log_name

  # Check interval in seconds
  sleep 10
done
